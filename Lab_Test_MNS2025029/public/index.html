<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>DH WASM Demo (final)</title>
  <style>
    body { font-family: Arial, sans-serif; max-width:900px; margin:20px; }
    input { width: 160px; }
    pre { background:#f4f4f4; padding:12px; border-radius:6px; white-space: pre-wrap; }
    button[disabled] { opacity:0.6; }
  </style>
</head>
<body>
  <h2>Diffie-Hellman demo (WASM client + native server)</h2>

  <p>Enter p and g. Client picks random a & computes x = g^a mod p using WASM. Server picks b, computes y = g^b mod p and K = x^b mod p using native program.</p>

  <label>p: <input id="p" type="number" value="11"></label><br><br>
  <label>g: <input id="g" type="number" value="2"></label><br><br>
  <button id="startBtn" disabled>Connect</button>

  <h3>Results</h3>
  <pre id="log">WASM not loaded yet...</pre>

  <!-- Module object for emscripten runtime -->
  <script>
    var Module = {
      onRuntimeInitialized: function () {
        document.getElementById('log').textContent = 'WASM loaded. Detecting call signature...';
        try {
          setupModexpWrapper();
          console.log("WASM loaded. Signature:", window._modexpSignedWith);
          document.getElementById('startBtn').disabled = false;
          document.getElementById('log').textContent = 'WASM loaded. Enter p and g, then click Start.';
        } catch (e) {
          document.getElementById('log').textContent = 'WASM loaded but setup failed: ' + e;
          console.error(e);
        }
      },
      print: (t) => console.log(t),
      printErr: (t) => console.error(t)
    };

    window.computeModexp = null;
    window._modexpSignedWith = null;

    function setupModexpWrapper() {
      // First: if direct export is present as Module._modexp, try to use it
      const direct = Module && Module._modexp;
      if (direct) {
        // Probe if it accepts BigInt or Number
        // Try BigInt call first (safe if function expects BigInt)
        try {
          // small probing values
          const probe = direct(BigInt(2), BigInt(3), BigInt(11));
          // if no exception, bigInt path works
          window._modexpSignedWith = 'bigint';
          window.computeModexp = (base, exp, mod) => {
            // ensure strings or numeric convert to BigInt safely
            return String(direct(BigInt(base), BigInt(exp), BigInt(mod)));
          };
          return;
        } catch (e) {
          // BigInt call failed â€” try number call
        }
        try {
          const probe2 = direct(2, 3, 11);
          // if no exception, number path works
          window._modexpSignedWith = 'number';
          window.computeModexp = (base, exp, mod) => {
            return String(direct(Number(base), Number(exp), Number(mod)));
          };
          return;
        } catch (e2) {
          // fallthrough to cwrap approach
          console.warn('Direct Module._modexp exists but probing failed; falling back to cwrap.');
        }
      }

      // Second: try cwrap number / bigint forms (safe fallback)
      const cwrap = Module.cwrap.bind(Module);
      let numFn = null, bigFn = null;
      try { numFn = cwrap('_modexp', 'number', ['number','number','number']); } catch(_) {}
      try { bigFn = cwrap('_modexp', 'bigint', ['bigint','bigint','bigint']); } catch(_) {}

      if (numFn) {
        window._modexpSignedWith = 'number';
        window.computeModexp = (base, exp, mod) => {
          const out = numFn(Number(base), Number(exp), Number(mod));
          return String(Math.trunc(out));
        };
        return;
      }
      if (bigFn) {
        window._modexpSignedWith = 'bigint';
        window.computeModexp = (base, exp, mod) => {
          const out = bigFn(BigInt(base), BigInt(exp), BigInt(mod));
          return out.toString();
        };
        return;
      }

      // If we reached here, we do not have a usable export.
      throw new Error('modexp export not found (no direct export and no cwrap). Check compute.js exports.');
    }
  </script>

  <!-- Emscripten glue / wasm -->
  <script src="compute.js"></script>

  <script>
    function rndZp(p) {
      p = Math.floor(p);
      if (p <= 2) return 1;
      return Math.floor(Math.random() * (p - 1)) + 1;
    }

    async function start() {
      const p = Number(document.getElementById('p').value);
      const g = Number(document.getElementById('g').value);
      if (!Number.isInteger(p) || !Number.isInteger(g) || p < 2) {
        alert('Enter integer p and g (p prime recommended).');
        return;
      }

      const a = rndZp(p);

      // computeModexp returns decimal string
      const xStr = computeModexp(String(g), String(a), String(p));

      const log = document.getElementById('log');
      log.textContent = `Client chosen a = ${a}\nComputed x = g^a mod p = ${xStr}\n\nSending <g,p,x> to server...`;

      try {
        const resp = await fetch('/run', {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify({ g: String(g), p: String(p), x: String(xStr) })
        });
        const data = await resp.json();
        if (data.error) {
          log.textContent += '\nServer error: ' + data.error;
        } else {
          log.textContent += `\n\nServer responded:\ny = ${data.y}\nK = ${data.K}\na = ${a}\n\n(Displayed: <K, y, a>)`;
        }
      } catch (err) {
        log.textContent += '\nNetwork or server error: ' + err;
      }
    }

    document.getElementById('startBtn').addEventListener('click', start);
  </script>
</body>
</html>


